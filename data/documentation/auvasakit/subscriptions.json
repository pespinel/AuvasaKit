{"identifier":{"url":"doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/Subscriptions","interfaceLanguage":"swift"},"kind":"article","abstract":[{"text":"Subscribe to continuous real-time updates using AsyncStream.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/RealTimeData","doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/AuvasaClient"],"title":"Related Documentation","anchor":"Related-Documentation"},{"identifiers":["doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/RealTimeData"],"title":"Real-Time Features","generated":true,"anchor":"Real-Time-Features"}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of manually polling for updates, AuvasaKit provides subscription APIs that deliver continuous data streams. Subscriptions use Swift’s "},{"type":"codeVoice","code":"AsyncStream"},{"type":"text","text":" and automatically handle:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Periodic polling (configurable interval, default 30s)"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Error recovery with automatic retries"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Proper cleanup when cancelled"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Thread-safe operation with actors"}]}]}]},{"type":"heading","text":"Vehicle Position Subscriptions","level":2,"anchor":"Vehicle-Position-Subscriptions"},{"type":"heading","text":"Subscribe to All Vehicles","level":3,"anchor":"Subscribe-to-All-Vehicles"},{"type":"paragraph","inlineContent":[{"text":"Receive updates for all active buses:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await positions in client.subscribeToVehiclePositions() {","    print(\"Received \\(positions.count) vehicle positions\")","","    \/\/ Update your map or UI","    for vehicle in positions {","        updateMapMarker(","            id: vehicle.id,","            coordinate: vehicle.position,","            bearing: vehicle.bearing","        )","    }","}"]},{"type":"heading","text":"Subscribe to Specific Route","level":3,"anchor":"Subscribe-to-Specific-Route"},{"type":"paragraph","inlineContent":[{"text":"Track only buses on a particular route:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await positions in client.subscribeToVehiclePositions(routeId: \"L1\") {","    print(\"Line 1 has \\(positions.count) active buses\")","","    for vehicle in positions {","        print(\"  \\(vehicle.vehicle.label ?? \"?\"): \\(vehicle.position)\")","    }","}"]},{"type":"heading","text":"Track Nearby Vehicles","level":3,"anchor":"Track-Nearby-Vehicles"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use a Task to filter positions by distance:"}]},{"type":"codeListing","syntax":"swift","code":["let userLocation = Coordinate(latitude: 41.6523, longitude: -4.7245)","","for await positions in client.subscribeToVehiclePositions() {","    let nearbyBuses = positions.filter {","        userLocation.distance(to: $0.position) < 1000  \/\/ Within 1km","    }","","    if !nearbyBuses.isEmpty {","        print(\"\\(nearbyBuses.count) buses nearby\")","        \/\/ Trigger notification or update UI","    }","}"]},{"type":"heading","text":"Trip Update Subscriptions","level":2,"anchor":"Trip-Update-Subscriptions"},{"type":"heading","text":"Subscribe to Stop Arrivals","level":3,"anchor":"Subscribe-to-Stop-Arrivals"},{"type":"paragraph","inlineContent":[{"text":"Get continuous arrival predictions for a stop:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await updates in client.subscribeToTripUpdates(stopId: \"123\") {","    print(\"Arrival updates for stop 123:\")","","    for update in updates {","        \/\/ Find arrival time for this specific stop","        for stopUpdate in update.stopTimeUpdates where stopUpdate.stopId == \"123\" {","            if let arrival = stopUpdate.arrival {","                let arrivalDate = Date(timeIntervalSince1970: TimeInterval(arrival.time))","                print(\"  Trip \\(update.trip.routeId): \\(arrivalDate)\")","","                if let delay = arrival.delay {","                    print(\"    Delay: \\(delay)s\")","                }","            }","        }","    }","}"]},{"type":"heading","text":"Subscribe to All Trip Updates","level":3,"anchor":"Subscribe-to-All-Trip-Updates"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Monitor all active trips:"}]},{"type":"codeListing","syntax":"swift","code":["for await updates in client.subscribeToTripUpdates() {","    print(\"Received \\(updates.count) trip updates\")","","    \/\/ Find trips with significant delays","    let delayedTrips = updates.filter { ($0.delay ?? 0) > 300 }  \/\/ > 5 min","","    if !delayedTrips.isEmpty {","        print(\"⚠️ \\(delayedTrips.count) trips delayed > 5 minutes\")","    }","}"]},{"type":"heading","text":"Alert Subscriptions","level":2,"anchor":"Alert-Subscriptions"},{"type":"heading","text":"Subscribe to All Alerts","level":3,"anchor":"Subscribe-to-All-Alerts"},{"type":"paragraph","inlineContent":[{"text":"Monitor service disruptions:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await alerts in client.subscribeToAlerts() {","    if !alerts.isEmpty {","        print(\"⚠️ \\(alerts.count) active alerts:\")","","        for alert in alerts {","            print(\"  \\(alert.headerText)\")","            print(\"  Severity: \\(alert.severity)\")","        }","","        \/\/ Show notification to user","        showAlertNotification(alerts)","    }","}"]},{"type":"heading","text":"Subscribe to Route Alerts","level":3,"anchor":"Subscribe-to-Route-Alerts"},{"type":"paragraph","inlineContent":[{"text":"Track alerts for a specific route:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await alerts in client.subscribeToAlerts(routeId: \"L1\") {","    if !alerts.isEmpty {","        print(\"Line 1 alerts:\")","        for alert in alerts {","            print(\"  \\(alert.descriptionText)\")","        }","    }","}"]},{"type":"heading","text":"Subscribe to Stop Alerts","level":3,"anchor":"Subscribe-to-Stop-Alerts"},{"type":"paragraph","inlineContent":[{"text":"Monitor alerts affecting a particular stop:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await alerts in client.subscribeToAlerts(stopId: \"123\") {","    for alert in alerts {","        \/\/ Check if alert affects our stop","        if alert.informedEntities.contains(where: { $0.stopId == \"123\" }) {","            print(\"Alert at stop: \\(alert.headerText)\")","        }","    }","}"]},{"type":"heading","text":"Subscribe to Active Alerts Only","level":3,"anchor":"Subscribe-to-Active-Alerts-Only"},{"type":"paragraph","inlineContent":[{"text":"Filter for currently active alerts:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["for await alerts in client.subscribeToActiveAlerts() {","    print(\"\\(alerts.count) alerts active right now\")","}"]},{"type":"heading","text":"Managing Subscriptions","level":2,"anchor":"Managing-Subscriptions"},{"type":"heading","text":"Cancellation","level":3,"anchor":"Cancellation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Subscriptions run until cancelled. Use Swift’s structured concurrency:"}]},{"type":"codeListing","syntax":"swift","code":["let task = Task {","    for await positions in client.subscribeToVehiclePositions() {","        updateUI(with: positions)","    }","}","","\/\/ Later, cancel the subscription","task.cancel()"]},{"type":"heading","text":"Structured Concurrency","level":3,"anchor":"Structured-Concurrency"},{"type":"paragraph","inlineContent":[{"text":"Use task groups for multiple subscriptions:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["await withTaskGroup(of: Void.self) { group in","    \/\/ Subscribe to vehicles","    group.addTask {","        for await positions in client.subscribeToVehiclePositions() {","            updateVehicles(positions)","        }","    }","","    \/\/ Subscribe to alerts","    group.addTask {","        for await alerts in client.subscribeToAlerts() {","            updateAlerts(alerts)","        }","    }","","    \/\/ Subscriptions run until task group is cancelled","}"]},{"type":"heading","text":"SwiftUI Integration","level":3,"anchor":"SwiftUI-Integration"},{"type":"paragraph","inlineContent":[{"text":"Use ","type":"text"},{"code":"@State","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Task","type":"codeVoice"},{"text":" in SwiftUI:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct BusMapView: View {","    @State private var vehicles: [VehiclePosition] = []","    @State private var subscriptionTask: Task<Void, Never>?","","    var body: some View {","        Map {","            ForEach(vehicles) { vehicle in","                Annotation(vehicle.vehicle.label ?? \"?\", coordinate: vehicle.position.clLocation) {","                    BusMarker(vehicle: vehicle)","                }","            }","        }","        .onAppear {","            subscriptionTask = Task {","                for await positions in client.subscribeToVehiclePositions() {","                    vehicles = positions","                }","            }","        }","        .onDisappear {","            subscriptionTask?.cancel()","        }","    }","}"]},{"type":"heading","text":"Configuration","level":2,"anchor":"Configuration"},{"type":"heading","text":"Polling Interval","level":3,"anchor":"Polling-Interval"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Configure the polling interval when creating the client:"}]},{"type":"codeListing","syntax":"swift","code":["let config = AuvasaClient.Configuration(","    pollingInterval: 15  \/\/ Poll every 15 seconds",")","let client = AuvasaClient(configuration: config)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Shorter intervals provide more up-to-date data but increase network usage. The default 30 seconds balances freshness with efficiency."}]},{"type":"heading","text":"Error Handling","level":3,"anchor":"Error-Handling"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Subscriptions automatically retry on transient errors:"}]},{"type":"codeListing","syntax":"swift","code":["for await positions in client.subscribeToVehiclePositions() {","    \/\/ Stream continues even if individual requests fail","    \/\/ Errors are logged but don't break the subscription","}"]},{"type":"paragraph","inlineContent":[{"text":"For critical errors (e.g., authentication failure), the stream will terminate and you can catch the error:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["do {","    for await positions in client.subscribeToVehiclePositions() {","        updateUI(with: positions)","    }","} catch {","    print(\"Subscription failed: \\(error)\")","    \/\/ Handle fatal error","}"]},{"type":"heading","text":"Best Practices","level":2,"anchor":"Best-Practices"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Cancel Properly"}],"type":"strong"},{"text":": Always cancel subscriptions when no longer needed to free resources","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Use Structured Concurrency"}]},{"type":"text","text":": Leverage task groups and task hierarchies for automatic cleanup"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Filter Early"}]},{"type":"text","text":": Apply filters to reduce data processing"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Batch Updates"}]},{"type":"text","text":": Consider debouncing UI updates when processing high-frequency streams"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Monitor Memory","type":"text"}]},{"text":": Large subscription buffers can consume memory - cancel inactive subscriptions","type":"text"}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/auvasakit\/subscriptions"]}],"sections":[],"metadata":{"roleHeading":"Article","modules":[{"name":"AuvasaKit"}],"role":"article","title":"Subscriptions"},"hierarchy":{"paths":[["doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit"]]},"references":{"doc://auvasakit.AuvasaKit/documentation/AuvasaKit/RealTimeData":{"type":"topic","url":"\/documentation\/auvasakit\/realtimedata","identifier":"doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/RealTimeData","kind":"article","title":"Real-Time Data","role":"article","abstract":[{"text":"Access live transit information from AUVASA’s GTFS Real-Time feed.","type":"text"}]},"doc://auvasakit.AuvasaKit/documentation/AuvasaKit":{"identifier":"doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit","kind":"symbol","title":"AuvasaKit","url":"\/documentation\/auvasakit","abstract":[{"type":"text","text":"Modern Swift SDK for accessing AUVASA (Autobuses Urbanos de Valladolid) transit data."}],"role":"collection","type":"topic"},"doc://auvasakit.AuvasaKit/documentation/AuvasaKit/AuvasaClient":{"title":"AuvasaClient","fragments":[{"kind":"keyword","text":"actor"},{"kind":"text","text":" "},{"kind":"identifier","text":"AuvasaClient"}],"identifier":"doc:\/\/auvasakit.AuvasaKit\/documentation\/AuvasaKit\/AuvasaClient","kind":"symbol","url":"\/documentation\/auvasakit\/auvasaclient","abstract":[{"type":"text","text":"Main client for accessing AUVASA bus data"}],"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AuvasaClient"}]}}}